<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Mesh Edit</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2018</h1>
<h1 align="middle">Project 2: Mesh Edit</h1>
<h2 align="middle">Preston Fu and Ralph Cao</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

<h3 align="middle">Part 1: Bezier Curves with 1D de Casteljau Subdivision</h3>


<b>
  Briefly explain de Casteljau's algorithm and how you implemented it in order to evaluate Bezier curves.
</b>
<p>
  de Casteljau's algorithm works as follows. We begin with the control points of the
  BÃ©zier curve (make a copy). Repeat the following process recursively: for each iteration, 
  linearly interpolate between adjacent control points. That is, with some control
	points $\{p_i\}_{i=1}^n$, one iteration of the update will be $\{(1-t)p_i + tp_{i+1}\}_{i=1}^{n-1}$.
	In the code, this is implemented as `BezierCurve::evaluateStep`.
</p>
<p>
	Eventually, we will have one point, which is the point corresponding to $t$.
	Treat this as a function of $t \in [0, 1]$ to obtain the Bezier curves.
</p>
<br>


<b>
  Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.
</b>
<p></p>
<b>
  Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press <kbd>E</kbd> to step through. Toggle <kbd>C</kbd> to show the completed Bezier curve as well.
</b>
<p></p>
<!-- Example of including a single figure -->

<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/1/0.png" align="middle" width="250px" />
        <figcaption>Level 0 (control points)</figcaption>
      </td>
      <td align="middle">
        <img src="images/1/1.png" align="middle" width="250px" />
        <figcaption>Level 1</figcaption>
      </td>
      <td align="middle">
        <img src="images/1/2.png" align="middle" width="250px" />
        <figcaption>Level 2</figcaption>
      </td>
    </tr>
    <tr>
      <td align="middle">
        <img src="images/1/3.png" align="middle" width="250px" />
        <figcaption>Level 3</figcaption>
      </td>
      <td align="middle">
        <img src="images/1/4.png" align="middle" width="250px" />
        <figcaption>Level 4</figcaption>
      </td>
      <td align="middle">
        <img src="images/1/5.png" align="middle" width="250px" />
        <figcaption>Level 5 (one point)</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<p>The final curve is as shown.</p>

<div align="middle">
  <img src="images/1/curve.png" align="middle" width="250px">
</div>
<br>


<b>
  Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter \(t\) via mouse scrolling.
</b>
<br>
<div align="middle">
  <img src="images/1/another-curve.png" align="middle" width="250px">
</div>
<br>
<br>


<h3 align="middle">Part 2: Bezier Surfaces with Separable 1D de Casteljau</h3>
<b>
  Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.
</b>
<p>
	Evaluating Bezier surfaces can be done in a separable manner. That is, run 1D de Casteljau
	to interpolate between adjacent points in the $x$ direction for each fixed $y$ value,
	giving control points. Then use 1D de Casteljau using these control points to interpolate
	in the $y$ direction.
</p>
<p>
	In implementation, the approach is quite similar to the 1D case. We replaced
	<kbd>Vector2D</kbd> with <kbd>Vector3D</kbd> and used the two-step evaluation method described above.
</p>
<br>


<b>
  Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.
</b>
<div align="middle">
  <img src="images/task2.png" align="middle" width="50%">
</div>
<br>


<h2 align="middle">Section II: Triangle Meshes and Half-Edge Data Structure</h2>

<h3 align="middle">Part 3: Area-Weighted Vertex Normals</h3>

<b>
  Briefly explain how you implemented the area-weighted vertex normals.
</b>
<p>
    For each triangle, we traversed all of the edges of adjacent polygons and computed the sum the cross products of each adjacent pair of edges. For a given polygon, 
    calculating the sum of the cross products of each adjacent pair of edges would return a vector that is perpendicular to the plane of the polygon with magnitude 
    equal to twice the area of the polygon. In this way, assuming each polygon is planar, calculating this sum across all adjacent polygons would give us an area-weighted sum,
    which would give us the area-weighted vertex normal once normalized.
</p>
<br>


<b>
  Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use <kbd>Q</kbd> to toggle default flat shading and Phong shading.
</b>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task3_a.png" align="middle" width="400px" />
        <figcaption>Flat Shading</figcaption>
      </td>
      <td align="middle">
        <img src="images/task3_b.png" align="middle" width="400px" />
        <figcaption align="middle">Phong Shading</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<h3 align="middle">Part 4: Edge Flip</h3>
<b>
  Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
  Show screenshots of the teapot before and after some edge flips.
</b>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task4_a.png" align="middle" width="400px" />
        <figcaption>Before Flips</figcaption>
      </td>
      <td align="middle">
        <img src="images/task4_b.png" align="middle" width="400px" />
        <figcaption align="middle">After Flips</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<h3 align="middle">Part 5: Edge Split</h3>
<b>
  Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
	Our implementation is shown in the figure. The input edge <kbd>e0</kbd> has associated
	halfedges 1 and 2, which are on faces A and B, respectively. To preserve
	some elements of our original setup, we maintain that 1 and 2 are on A and B,
	but change most of the rest of this setup.

	<div align="middle">
	<figure>
		<img src="images/edge-split-start.png" width="300px" />
		<img src="images/edge-split-end.png" width="400px" />
		<figcaption>Two adjacent triangles before (left) and after (right) an edge split.</figcaption>
	</figure>
	</div>

	Specifically, our process looks like:
	<ol>
		<li>Create new edges.</li>
		<li>Update halfedges' <kbd>twin</kbd> and <kbd>next</kbd> attributes.</li>
		<li>Update edges' halfedges.</li>
		<li>Update faces' halfedges and halfedges' faces.</li>
		<li>Update vertices.</li>
	</ol>
</p>
<br>


<b>
    Show screenshots of a mesh before and after some edge splits. 
</b>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task5_a.png" align="middle" width="400px" />
        <figcaption>Before Splits</figcaption>
      </td>
      <td align="middle">
        <img src="images/task5_b.png" align="middle" width="400px" />
        <figcaption align="middle">After Splits</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<b>
    Show screenshots of a mesh before and after a combination of both edge splits and edge flips.
</b>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task5_c.png" align="middle" width="400px" />
        <figcaption>Before Splits and Flips</figcaption>
      </td>
      <td align="middle">
        <img src="images/task5_d.png" align="middle" width="400px" />
        <figcaption align="middle">After Splits and Flips</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<b>
    Write about your eventful debugging journey, if you have experienced one.
</b>
<p>
	We didn't need to debug! Our first implementation was correct.
</p>
<br>


<b>
    If you have implemented support for boundary edges, show screenshots of your implementation properly handling split operations on boundary edges.
</b>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task5_e.png" align="middle" width="400px" />
        <figcaption>Before Splits</figcaption>
      </td>
      <td align="middle">
        <img src="images/task5_f.png" align="middle" width="400px" />
        <figcaption align="middle">After Splits</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<h3 align="middle">Part 6: Loop Subdivision for Mesh Upsampling</h3>
<b>
  Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.
</b>
<p>
	We follow the algorithm described in the spec:
	<ol>
		<li>Update the <kbd>newPosition</kbd> of each vertex in the mesh as a weighted average of the current position and neighboring vertices' positions.</li>
		<li>
			Each edge will get split. Update the <kbd>newPosition</kbd> of each edge in the mesh, which is a weighted average of the positions
			of the vertices in the triangles containing that edge.
		</li>
		<li>
			Split each edge. We store the number of required edges to split on, so that we do not split the new edges
			we just created (which would result in an infinite loop).
		</li>
		<li>
			Flip every new edge that is between one new vertex and one old vertex.
		</li>
		<li>
			Update all vertex positions.
		</li>
	</ol>

	Originally, after subdivision, our mesh had the correct shape but had holes. We commented out some lines
	of code and found that the problem was in edge flips. It turned out that our problem was with (3),
	and storing the number of edges was sufficient. (We realized during this process that setting
	a variable as a pointer to the end of the list didn't work since it got updated dynamically.)
</p>
<br>


<b>
  Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?
</b>
<p>
	Sharp edges and corners get rounded out. This is no surprise because the loop subdivision weighting
	will pull these sharp components towards the center of the cube due to the weighted averaging.
  We have alleviated this effect by splitting each edge into 4.
</p>
<div align="middle">
	<figure>
		<img src="images/6/cube-spam.png" width="300px" />
		<figcaption>Cube with 48 edge splits.</figcaption>
	</figure>
</div>
<p>
  Indeed, we can compare to the figures in the following question (where we have only split on the faces)
  and observe that the edges and overall cube shape are much more pronounced with sharp edge splits.
</p>


<b>
  Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.
</b>
<p>
  The problem with the original mesh is that the edges across each face are not symmetric,
  causing the subdivision process to produce an asymmetric mesh. Pre-splitting the edges
  on each face resolves this:
</p>
<div align="middle">
	<figure>
		<img src="images/6/cube-og.png" width="300px" />
		<img src="images/6/cube-split.png" width="300px" />
		<img src="images/6/cube-final.png" width="300px" />
		<figcaption>Original cube mesh (left), after splitting (middle), and after loop subdivision (right).</figcaption>
	</figure>
</div>

<b>
    If you have implemented any extra credit extensions, explain what you did and document how they work with screenshots.
</b>
<p>
    We additionally implemented $\sqrt{3}-$subdivision, and implemented boundary support for both loop subdivision and $\sqrt{3}-$subdivision.
</p>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td align="middle">
        <img src="images/task6_ec_a.png" align="middle" width="500px" />
        <figcaption>Before Subdivision</figcaption>
      </td>
      <td align="middle">
        <img src="images/task6_ec_b.png" align="middle" width="500px" />
        <figcaption align="middle">After Loop Subdivision</figcaption>
      </td>
    </tr>
    <tr>
      <td align="middle">
        <img src="images/task6_ec_c.png" align="middle" width="500px" />
        <figcaption align="middle">After $\sqrt{3}-$Subdivision Once</figcaption>
      </td>
      <td align="middle">
        <img src="images/task6_ec_d.png" align="middle" width="500px" />
        <figcaption align="middle">After $\sqrt{3}-$Subdivision Twice</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>


<h3 align="middle">Part 7 (Optional, Possible Extra Credit)</h3>
<b>
    Save your best polygon mesh as partsevenmodel.dae in your docs folder and show us a screenshot of the mesh in your write-up.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Include a series of screenshots showing your original mesh and your mesh after one and two rounds of subdivision. If you have used custom shaders, include screenshots of your mesh with those shaders applied as well.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


<b>
    Describe what you have done to enhance your mesh beyond the simple humanoid mesh described in the tutorial.
</b>
<p>
    YOUR RESPONSE GOES HERE
</p>
<br>


</body>
</html>