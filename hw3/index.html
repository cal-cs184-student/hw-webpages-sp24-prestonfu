<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <style>
      body {
        background-color: white;
        padding: 100px;
        width: 1000px;
        margin: auto;
        text-align: left;
        font-weight: 300;
        font-family: "Open Sans", sans-serif;
        color: #121212;
      }
      h1,
      h2,
      h3,
      h4 {
        font-family: "Source Sans Pro", sans-serif;
      }
      kbd {
        font-size: large;
        color: #121212;
      }
    </style>
    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
    ></script>
    <title>CS 184 Path Tracer</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link
      href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro"
      rel="stylesheet"
    />

    <script>
      MathJax = {
        tex: {
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
    ></script>
  </head>

  <body>
    <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2024</h1>
    <h1 align="middle">Project 3-1: Path Tracer</h1>
    <h2 align="middle">Preston Fu and Ralph Cao</h2>

    <!-- Add Website URL -->
    <h2 align="middle">
      Website URL:
      <a
        href="https://cal-cs184-student.github.io/hw-webpages-sp24-prestonfu/hw3/index.html"
        >https://cal-cs184-student.github.io/hw-webpages-sp24-prestonfu/hw3/index.html</a
      >
    </h2>

    <br /><br />

    <h2 align="middle">Overview</h2>
    <p>YOUR RESPONSE GOES HERE</p>
    <br />

    <h2 align="middle">
      Part 1: Ray Generation and Scene Intersection (20 Points)
    </h2>
    <!-- Walk through the ray generation and primitive intersection parts of the rendering pipeline.
Explain the triangle intersection algorithm you implemented in your own words.
Show images with normal shading for a few small .dae files. -->

    <h3>
      Walk through the ray generation and primitive intersection parts of the
      rendering pipeline.
    </h3>
    <p>
      To generate a single ray from a camera given a point $(x,y)$ on the screen, 
      we first converted the screen point into camera world space through the 
      transformation
      \[(x,y)\to (2\tan(0.5\cdot hFov)(x-0.5),2\tan(0.5\cdot vFov)(y-0.5),-1)\]
      and then multiplied by the $c2w$ transformation matrix to get the resulting
      ray direction in world space, which we normalize. We use the camera position
      as the origin of the ray and return it with both clipping planes in min/max $t$.
    </p>
    <p>
      To determine the rays to generate, we looped through each pixel of the screen
      and sent randomly generated rays uniformly selected from within each pixel,
      and averaged the radiance calculated by the rest of the code based on intersections
      with primitives.
    </p>
    <br />

    <h3>
      Explain the triangle intersection algorithm you implemented in your own
      words.
    </h3>
    <p>
      We implemented the Moller-Trumbore algorithm from lecture. This optimized
      over the standard approach of solving for the intersection with the plane
      and checking that the intersection is inside the triangle with vertices
      $\mathbf P_1$, $\mathbf P_2$, $\mathbf P_3$. Specifically, for a ray
      parameterized by $(\mathbf o, \mathbf d)$, we can solve for scalars $b_2$
      and $b_3$ satisfying $\mathbf o + t \mathbf d= (1 - b_2 - b_3) \mathbf P_1
      + b_2 \mathbf P_2 +b_3 \mathbf P_3$ as \[ \begin{bmatrix} t\\ b_1 \\ b_2
      \end{bmatrix} = \frac 1{\mathbf S_2 \cdot \mathbf E_2}
      \begin{bmatrix}\mathbf S_3 \cdot \mathbf E_3 \\ \mathbf S_2 \cdot \mathbf
      S \\ \mathbf S_3 \cdot \mathbf d \end{bmatrix},\] where $\mathbf E_2 =
      \mathbf P_2 - \mathbf P_1$, $\mathbf E_3 = \mathbf P_3 - \mathbf P_1$,
      $\mathbf S = \mathbf o -\mathbf P_1$, $\mathbf S_1 = \mathbf d \times
      \mathbf E_3$, and $\mathbf S_2 = \mathbf S \times \mathbf E_2$. This
      approach confers a few benefits:
    </p>
    <ul>
      <li>Straightforward implementation.</li>
      <li>
        A long time ago, division was expensive to do. (And since there are lots
        of rays, it still is.) This algorithm only entails one divide.
      </li>
    </ul>
    <br />

    <h3>Show images with normal shading for a few small .dae files.</h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/part1/CBempty.png" align="middle" width="400px" />
            <figcaption>CBempty.dae</figcaption>
          </td>
          <td>
            <img
              src="images/part1/CBspheres.png"
              align="middle"
              width="400px"
            />
            <figcaption>CBspheres.dae</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/part1/CBcoil.png" align="middle" width="400px" />
            <figcaption>CBcoil.dae</figcaption>
          </td>
          <td>
            <img src="images/part1/cow.png" align="middle" width="400px" />
            <figcaption>cow.dae</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />

    <h2 align="middle">Part 2: Bounding Volume Hierarchy (20 Points)</h2>
    <!-- Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.
Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis. -->

    <h3>
      Walk through your BVH construction algorithm. Explain the heuristic you
      chose for picking the splitting point.
    </h3>
    <p>

    </p>

    <h3>
      Show images with normal shading for a few large .dae files that you can
      only render with BVH acceleration.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/part2/CBdragon.png" align="middle" width="400px" />
            <figcaption>CBdragon.dae</figcaption>
          </td>
          <td>
            <img src="images/part2/CBlucy.png" align="middle" width="400px" />
            <figcaption>CBlucy.dae</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/part2/CBbunny.png" align="middle" width="400px" />
            <figcaption>CBbunny.dae</figcaption>
          </td>
          <td>
            <img src="images/part2/blob.png" align="middle" width="400px" />
            <figcaption>blob.dae</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />

    <h3>
      Compare rendering times on a few scenes with moderately complex geometries
      with and without BVH acceleration. Present your results in a one-paragraph
      analysis.
    </h3>
    <p>The rendering times are shown in the table below.</p>
    <table style="width: 35%" align="center">
      <tr align="center">
        <th>Scene</th>
        <th>Without BVH (s)</th>
        <th>With BVH (s)</th>
      </tr>
      <tr align="center">
        <td>CBcoil.dae</td>
        <td>40.9131</td>
        <td>0.1457</td>
      </tr>
      <tr align="center">
        <td>cow.dae</td>
        <td>29.6984</td>
        <td>0.1387</td>
      </tr>
    </table>
    <br />

    <h2 align="middle">Part 3: Direct Illumination (20 Points)</h2>
    <!-- Walk through both implementations of the direct lighting function.
Show some images rendered with both implementations of the direct lighting function.
Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.
Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis. -->

    <h3>Walk through both implementations of the direct lighting function.</h3>
    <p>
      We implement direct lighting with two sampling methods, i.e. uniform
      hemisphere sampling (<kbd>estimate_direct_lighting_hemisphere</kbd>) and
      lighting importance sampling
      (<kbd>estimate_direct_lighting_importance</kbd>). In either case, we
      consider a ray $r = (\mathbf o, \mathbf d)$, which hits an object
      $\mathcal O$ as specified by <kbd>isect</kbd>. The corresponding hit point
      is given by $\mathbf p$ (<kbd>hit_p</kbd>). To compute the incoming
      radiance at $\mathbf o$ in the direction of $\mathbf d$, we observe that
      the radiance along a ray is constant, and we can estimate this by sampling
      directions $\omega_i$ centered at $\mathbf p$. In either case, we maintain
      a running radiance total along these samples in $L_{\text{out}}$, then
      divide by <kbd>num_samples</kbd> in the end.
    </p>

    <p>
      In the uniform hemisphere sampling case, we use
      <kbd>hemisphereSampler->get_sample()</kbd>, and check whether our ray with
      outgoing direction $\omega_i$ (incoming direction $-\omega_i$) intersects
      a light soure. In this case, we increment $L_{\text{out}}$ by \[
      \frac{f(\omega_{\text{out}} \to \text{w2o}(\omega_i)) L_i(\mathbf p,
      \omega_i) (\omega_i \cdot \mathbf n)}{1/2\pi}, \] where $f$ denotes a
      bidirectional scattering distribution function (BSDF) for diffuse
      surfaces, $\text{w2o}$ denotes a conversion from world to object
      coordinates based on the normal $\mathbf n$ at $\mathbf p$ on the surface
      of $\mathcal O$, $L_i$ denotes the emission at the light source, the dot
      product indicates the cosine angle between the incoming ray and normal
      vector, and $\frac 1{2\pi}$ is the pdf of uniformly sampling $\omega_i$
      from the hemisphere.
    </p>

    <p>
      In the light source importance sampling case, we use loop over the lights,
      and for each one collect samples via <kbd>light->sample_L</kbd> (1 sample
      if it is a point source light and <kbd>ns_area_light</kbd> otherwise).
      From each sample $\omega_i$, we cast a ray $r$ and evaluate the incoming
      radiance $L_i(\mathbf p, \omega_i)$, pdf $p$, and distance $d$ to the
      light source. We check whether the light source is directly visible from
      $\mathbf p$ by checking whether $r$ restricted to $[\varepsilon, d -
      \varepsilon]$ does not have any intersections. In this case, we increment
      $L_{\text{out}}$ by \[ \frac{f(\omega_{\text{out}} \to
      \text{w2o}(\omega_i)) L_i(\mathbf p, \omega_i) (\omega_i \cdot \mathbf
      n)}{p(\omega_i)}, \] following the same notation as above.
    </p>

    <h3>
      Show some images rendered with both implementations of the direct lighting
      function.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <!-- Header -->
        <tr align="center">
          <th>
            <b>Uniform Hemisphere Sampling</b>
          </th>
          <th>
            <b>Light Sampling</b>
          </th>
        </tr>
        <br />
        <tr align="center">
          <td>
            <img
              src="images/part3/CBbunny_H_16_8.png"
              align="middle"
              width="400px"
            />
            <figcaption>
              CBbunny.dae, 16 rays per pixel, 8 samples per light source
            </figcaption>
          </td>
          <td>
            <img
              src="images/part3/bunny_1_1.png"
              align="middle"
              width="400px"
            />
            <figcaption>
              CBbunny.dae, 1 ray per pixel, 1 sample per light source
            </figcaption>
          </td>
        </tr>
        <br />
        <tr align="center">
          <td>
            <img
              src="images/part3/CBbunny_H_64_32.png"
              align="middle"
              width="400px"
            />
            <figcaption>
              CBbunny.dae, 64 rays per pixel, 32 samples per light source
            </figcaption>
          </td>
          <td>
            <img
              src="images/part3/bunny_64_32.png"
              align="middle"
              width="400px"
            />
            <figcaption>
              CBbunny.dae, 64 rays per pixel, 32 samples per light source
            </figcaption>
          </td>
        </tr>
        <br />
      </table>
    </div>
    <br />

    <h3>
      Focus on one particular scene with at least one area light and compare the
      noise levels in <b>soft shadows</b> when rendering with 1, 4, 16, and 64
      light rays (the -l flag) and with 1 sample per pixel (the -s flag) using
      light sampling, <b>not</b> uniform hemisphere sampling.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img
              src="images/part3/bunny_1_1.png"
              align="middle"
              width="200px"
            />
            <figcaption>1 Light Ray (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img
              src="images/part3/bunny_1_4.png"
              align="middle"
              width="200px"
            />
            <figcaption>4 Light Rays (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img
              src="images/part3/bunny_1_16.png"
              align="middle"
              width="200px"
            />
            <figcaption>16 Light Rays (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img
              src="images/part3/bunny_1_64.png"
              align="middle"
              width="200px"
            />
            <figcaption>64 Light Rays (CBbunny.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <p>YOUR EXPLANATION GOES HERE</p>
    <br />

    <h3>
      Compare the results between uniform hemisphere sampling and lighting
      sampling in a one-paragraph analysis.
    </h3>
    <p>YOUR RESPONSE GOES HERE</p>
    <br />

    <h2 align="middle">Part 4: Global Illumination (20 Points)</h2>
    <!--
./pathtracer -t 8 -s 1024 -l 16 -m 5 -r 480 360 -f spheres_global.png ../dae/sky/CBspheres_lambertian.dae
./pathtracer -t 8 -s 1024 -l 16 -m 5 -r 480 360 -f bunny_global.png ../dae/sky/CBbunny.dae

Direct only and indirect only (modify pathtracer)
./pathtracer -t 8 -s 1024 -l 16 -r 480 360 -f bunny_direct.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 5 -r 480 360 -f bunny_indirect.png ../dae/sky/CBbunny.dae

Accumulate = false, no russian roulette (or p=1)
./pathtracer -t 8 -s 1024 -l 16 -m 0 -o 0 -r 480 360 -f bunny_0.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 1 -o 0 -r 480 360 -f bunny_1.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 2 -o 0 -r 480 360 -f bunny_2.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 3 -o 0 -r 480 360 -f bunny_3.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 4 -o 0 -r 480 360 -f bunny_4.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 5 -o 0 -r 480 360 -f bunny_5.png ../dae/sky/CBbunny.dae

./pathtracer -t 8 -s 1024 -l 16 -m 0 -r 480 360 -f bunny_0_accumulate.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 1 -r 480 360 -f bunny_1_accumulate.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 2 -r 480 360 -f bunny_2_accumulate.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 3 -r 480 360 -f bunny_3_accumulate.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 4 -r 480 360 -f bunny_4_accumulate.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 5 -r 480 360 -f bunny_5_accumulate.png ../dae/sky/CBbunny.dae

Russian roulette
./pathtracer -t 8 -s 1024 -l 16 -m 0 -r 480 360 -f bunny_0_rr.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 1 -r 480 360 -f bunny_1_rr.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 2 -r 480 360 -f bunny_2_rr.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 3 -r 480 360 -f bunny_3_rr.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 16 -m 100 -r 480 360 -f bunny_100_rr.png ../dae/sky/CBbunny.dae


./pathtracer -t 8 -s 1 -l 4 -m 5 -r 480 360 -f bunny_s1.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 2 -l 4 -m 5 -r 480 360 -f bunny_s2.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 4 -l 4 -m 5 -r 480 360 -f bunny_s4.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 8 -l 4 -m 5 -r 480 360 -f bunny_s8.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 16 -l 4 -m 5 -r 480 360 -f bunny_s16.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 64 -l 4 -m 5 -r 480 360 -f bunny_s64.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 1024 -l 4 -m 5 -r 480 360 -f bunny_s1024.png ../dae/sky/CBbunny.dae

Part 5
./pathtracer -t 8 -s 2048 -l 1 -m 5 -r 480 360 -f bunny_adaptive.png ../dae/sky/CBbunny.dae
./pathtracer -t 8 -s 2048 -l 1 -m 5 -r 480 360 -f spheres_adaptive.png ../dae/sky/CBspheres_lambertian.dae


    -->

    <!-- Walk through your implementation of the indirect lighting function.
Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.
Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)
For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.
Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
You will probably want to use the instructional machines for the above renders in order to not burn up your own computer for hours. -->

    <h3>Walk through your implementation of the indirect lighting function.</h3>
    <p>
      For each ray, we additionally update the <kbd>depth</kbd>, which indicates
      the number of allowed bounces before truncation. We use Russian roulette
      where we keep $c = 65\%$ of the rays (or drop 35% of them). Our approach
      is recursive: for a ray $r$ and hit point $\mathbf p$, our base case is
      returning the one-bounce radiance if $r$ has depth 1. Otherwise, we cast a
      ray $r'$ from $\mathbf p$ with sampled outgoing direction $\omega_i$ in
      object coordinates. If the ray has an intersection at $\mathbf p'$, then
      we increment $L_{\text{out}}$ by \[
      \texttt{at_least_one_bounce_radiance}(r', \mathbf p')
      \frac{f(\omega_{\text{out}} \to \omega_i) (\omega_i \cdot
      \text{o2w}(\mathbf n))}{p(\omega_i) \cdot c}, \] following the same
      notation as above.
    </p>
    <br />
    <h3>
      Show some images rendered with global (direct and indirect) illumination.
      Use 1024 samples per pixel.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/bunny_global.png" align="middle" width="400px" />
            <figcaption>CBbunny.dae</figcaption>
          </td>
          <td>
            <img src="images/spheres_global.png" align="middle" width="400px" />
            <figcaption>CBspheres_lambertian.dae</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />

    <h3>
      Pick one scene and compare rendered views first with only direct
      illumination, then only indirect illumination. Use 1024 samples per pixel.
      (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in
      your code to generate these views.)
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Only direct illumination (example1.dae)</figcaption>
          </td>
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Only indirect illumination (example1.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />
    <p>YOUR EXPLANATION GOES HERE</p>
    <br />

    <h3>
      For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2,
      3, and 100 (the -m flag). Use 1024 samples per pixel.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>max_ray_depth = 0 (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>max_ray_depth = 1 (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>max_ray_depth = 2 (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>max_ray_depth = 3 (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>max_ray_depth = 100 (CBbunny.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />
    <p>YOUR EXPLANATION GOES HERE</p>
    <br />

    <h3>
      For CBbunny.dae, output the Russian Roulette rendering with max_ray_depth
      set to 0, 1, 2, 3, 4, and 100 (the -m flag). Use 1024 samples per pixel.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img
              src="images/part4/bunny_0_rr.png"
              align="middle"
              width="400px"
            />
            <figcaption>max_ray_depth = 0 (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img
              src="images/part4/bunny_1_rr.png"
              align="middle"
              width="400px"
            />
            <figcaption>max_ray_depth = 1 (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img
              src="images/part4/bunny_2_rr.png"
              align="middle"
              width="400px"
            />
            <figcaption>max_ray_depth = 2 (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img
              src="images/part4/bunny_3_rr.png"
              align="middle"
              width="400px"
            />
            <figcaption>max_ray_depth = 3 (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img
              src="images/part4/bunny_100_rr.png"
              align="middle"
              width="400px"
            />
            <figcaption>max_ray_depth = 100 (CBbunny.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />
    <p>YOUR EXPLANATION GOES HERE</p>
    <br />

    <h3>
      Pick one scene and compare rendered views with various sample-per-pixel
      rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/part4/bunny_s1.png" align="middle" width="400px" />
            <figcaption>1 sample per pixel (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img src="images/part4/bunny_s2.png" align="middle" width="400px" />
            <figcaption>2 samples per pixel (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/part4/bunny_s4.png" align="middle" width="400px" />
            <figcaption>4 samples per pixel (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img src="images/part4/bunny_s8.png" align="middle" width="400px" />
            <figcaption>8 samples per pixel (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img
              src="images/part4/bunny_s16.png"
              align="middle"
              width="400px"
            />
            <figcaption>16 samples per pixel (CBbunny.dae)</figcaption>
          </td>
          <td>
            <img
              src="images/part4/bunny_s64.png"
              align="middle"
              width="400px"
            />
            <figcaption>64 samples per pixel (CBbunny.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img
              src="images/part4/bunny_s1024.png"
              align="middle"
              width="400px"
            />
            <figcaption>1024 samples per pixel (CBbunny.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />
    <p>YOUR EXPLANATION GOES HERE</p>
    <br />

    <h2 align="middle">Part 5: Adaptive Sampling (20 Points)</h2>
    <!-- Explain adaptive sampling. Walk through your implementation of the adaptive sampling.
Pick one scene and render it with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth. -->

    <h3>
      Explain adaptive sampling. Walk through your implementation of the
      adaptive sampling.
    </h3>
    <p>
      Pixels converge at different rates, i.e. each pixel will need a different
      number of samples. Adaptive sampling handles this problem by running
      statistics with a normal prior, stopping ray tracing early for pixels
      where we confident in the true mean illuminance.
    </p>
    <p>
      We process samples in batches. Our samples are drawn uniformly from a
      grid, and from each sample, we evaluate the illuminance. To efficiently
      calculate the sample mean $\mu$ and variance $\sigma^2$, we maintain
      buffers for the sum and sum of squares of illuminance. At the end of each
      batch at which point there are $n$ total samples, we drop pixels for which
      the true mean illuminance lies in $[\mu - 1.96 \sigma / \sqrt n, \mu +
      1.96 \sigma / \sqrt n]$, where 1.96 is the required quantile to achieve
      95% confidence in the pixel value.
    </p>
    <br />

    <h3>
      Pick two scenes and render them with at least 2048 samples per pixel. Show
      a good sampling rate image with clearly visible differences in sampling
      rate over various regions and pixels. Include both your sample rate image,
      which shows your how your adaptive sampling changes depending on which
      part of the image you are rendering, and your noise-free rendered result.
      Use 1 sample per light and at least 5 for max ray depth.
    </h3>
    <!-- Example of including multiple figures -->
    <div align="middle">
      <table style="width: 100%">
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Rendered image (example1.dae)</figcaption>
          </td>
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Sample rate image (example1.dae)</figcaption>
          </td>
        </tr>
        <tr align="center">
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Rendered image (example2.dae)</figcaption>
          </td>
          <td>
            <img src="images/your_file.png" align="middle" width="400px" />
            <figcaption>Sample rate image (example2.dae)</figcaption>
          </td>
        </tr>
      </table>
    </div>
    <br />
  </body>
</html>
